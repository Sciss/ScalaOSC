h2. ScalaOSC ==<small>-- version 0.31-SNAPSHOT --</small>==

h3. statement

ScalaOSC is an OpenSoundControl (OSC) library for the Scala programming language. It is (C)opyright 2008&ndash;2011 by Hanns Holger Rutz. All rights reserved. ScalaOSC is released under the "GNU Lesser General Public License":http://www.sciss.de/scalaOSC/licenses/ScalaOSC-License.txt and comes with absolutely no warranties. To contact the author, send an email to @contact at sciss.de@

h3. requirements / installation

ScalaOSC currently cross-builds against Scala 2.9.1 (default) and. 2.9.0. Due to problems with specialization, cross-build for 2.8.1 is currently disabled. It uses the I/O API from Java 1.6. Use the "NetUtil":http://www.sciss.de/netutil/ Java OSC library if you require compatibility with Java SE 1.4.

ScalaOSC builds with sbt 0.11 (xsbt), and also contains a project file for Intellij IDEA 10 CE

The standard sbt targets are:

* @clean@ &ndash; removes previous build artefacts
* @compile@ &ndash; compiles classes into target/scala-version/classes
* @doc@ &ndash; generates api in target/scala-version/api/index.html
* @package@ &ndash; packages jar in target/scala-version
* @run@ __arguments...__ &ndash; prints info when run without arguments

h3. overview

OpenSoundControl (OSC) is a protocol to exchange messages between systems, typically over a network using UDP or TCP, and typically to control sound or multimedia applications.

OSC can be used to control sound software &ndash; for example "SuperCollider Server":http://supercollider.sf.net/ was one of the first systems to use OSC &ndash;, but also to communicate with hardware controllers.

OSC is a generic protocol and not restricted to sound applications: For example, "SwingOSC":http://www.sciss.de/swingOSC/ uses OSC to provide network access to the Java Virtual Machine.

For more information, known implementations and the protocol standard, visit "opensoundcontrol.org":http://opensoundcontrol.org/.

h3. implementation

ScalaOSC currently provides single ended channels (@Transmitter@ to send messages and @Receiver@ to run a receiving loop), as well as single sockets in bidirectional mode (@Client@).

The supported transports are UDP and TCP. A TCP server option is currently missing. If you need one, have a look at "NetUtil":http://www.sciss.de/netutil/.

ScalaOSC comes with a codec conforming with the strict "OSC 1.0 specification":http://opensoundcontrol.org/spec-1_0, as well as allowing for the optional types @h@ (64-bit integer), @d@ (64-bit floating point) and encoding OSC packets themselves as @b@ blobs, as used by SuperCollider. The codecs are customizable, thus support for other tags such as the booleans @T@ and @F@, characters @c@ or arrays @[ ]@ should be possible.

h3. documentation and examples

A very brief example showing two UDP clients playing ping-pong:

pre. import de.sciss.osc
// a sender, no target
val pingT = osc.UDP.Transmitter()
// a receiver, no target, but same channel as sender
val pingR = osc.UDP.Receiver( pingT.channel )
// a bidirectional client, targeted at ping's socket
val pong = osc.UDP.Client( pingT.localSocketAddress )
pingT.connect() // connect all channels
pingR.connect()
pong.connect()

pre. val t = new java.util.Timer()
def delay( code: => Unit ) {
   t.schedule( new java.util.TimerTask {
      def run { code }}, 500 )
}

pre. // unbound channels action takes packet and sender
pingR.action = {
   // match against a particular message
   case (m @ osc.Message( "/ping", c: Int ), s) =>
      println( "Ping received " + m )
      delay {
         pingT.send( osc.Message( "/pong", c ), s )
      }
   case _ => // ignore any other message
}

pre. // bound channels action takes just packet
var cnt = 0
pong.action = packet => {
   println( "Pong received " + packet )
   cnt += 1
   if( cnt <= 10 ) {
      // bound channels send via !(packet)
      delay { pong ! osc.Message( "/ping", cnt )}
   } else {
      pingR.close()
      pingT.close()
      pong.close()
      System.exit( 0 )
   }
}

pre. // unbound channels send via send(packet, addr)
pingT.send( osc.Message( "/start" ),
   pong.localSocketAddress )

Further examples can be found in the headers of the API docs, e.g. by looking up the documentation for @UDP.Client@.

ScalaOSC is used in the "ScalaCollider":http://www.sciss.de/scalaCollider/ project, so you may take a look at its usage there.

h3. todo

A TCP server is planned, as well as a file protocol conforming to SuperCollider's binary OSC file format. The latter will probably result in the addition of a @osc.Reader@ class which will be encapsulated by @osc.Receiver@. Thus, @osc.Transmitter@ might be renamed to @osc.Writer@, as it is synchronous and not threaded.

h3. download

The website is at "www.sciss.de/scalaOSC":http://www.sciss.de/scalaOSC/.
The current version can be downloaded from "github.com/Sciss/ScalaOSC":http://github.com/Sciss/ScalaOSC.
